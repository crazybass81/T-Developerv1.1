Understood. I’ll now examine the current state of the T‑Developer v1.1 repository and compare it with the latest version of the AWS Agent Squad repository. I’ll then create a detailed Markdown task directive that includes both:

* Complete architectural refactoring steps to migrate T‑Developer’s orchestrator to Agent Squad (removing all legacy orchestration logic unless CLI compatibility requires otherwise), and
* Documentation updates for design files to reflect the new Agent Squad-based orchestration structure, with instructions for execution sequencing, agent/team coordination, and registry alignment.

Test coverage of 80% will be a final requirement.


# Agent Squad Orchestrator Integration Plan

## Refactoring and Integration Tasks

* [ ] **Remove Legacy Orchestration Components (OrchestratorTeam & MetaAgent):** Eliminate the old orchestration layer entirely to make way for Agent Squad.

  * **Delete legacy classes:** Remove the `OrchestratorTeam` class (in `tdev/teams/orchestrator_team.py`) and the `MetaAgent` class (in `tdev/agents/meta_agent.py`) along with any associated files. These served as the previous orchestrator (MetaAgent coordinating Classifier/Planner/Evaluator/Executor) and are no longer needed once Agent Squad is in place.
  * **Purge registry entries:** Update the registry initialization to omit legacy orchestrator components. In `tdev/core/init_registry.py`, delete or comment out the registration of `"MetaAgent"` and `"OrchestratorTeam"`. This ensures the old orchestrator isn’t loaded into the system at startup.
  * **Remove CLI references:** Refactor or remove any CLI commands that invoke the legacy orchestrator. For example, the `tdev orchestrate` command currently looks up the `OrchestratorTeam` from the registry and calls its `run()` – this should be changed (or the command deprecated) since `OrchestratorTeam` will no longer exist. Similarly, eliminate usage of `MetaAgent` or `OrchestratorTeam` in helper functions or other modules. By fully excising these legacy hooks, we prevent confusion and ensure all orchestration flows through the new Agent Squad framework.

* [ ] **Introduce Agent Squad as the New Orchestrator:** Integrate the AWS open-source **Agent Squad** framework as the core orchestration mechanism, replacing T‑Developer’s custom logic.

  * **Add Agent Squad dependency:** Include the Agent Squad library (e.g. `awslabs/agent-squad`) in the project (via requirements or submodule). This provides the classes needed for multi-agent orchestration (Classifier, SupervisorAgent, etc.). Ensure the latest `main` branch is used for the integration to have all recent features (like SupervisorAgent).
  * **Initialize Agent Squad orchestrator:** Create a new top-level orchestrator component using Agent Squad. This could be done at runtime (for example, during CLI startup or when the first orchestration is invoked). If Agent Squad offers a high-level orchestrator class, instantiate it; otherwise, you will manually compose its components (classifier, agents, etc.) for T‑Developer. For instance, you might use Agent Squad’s **SupervisorAgent** as the primary orchestrator to manage the team of core agents.
  * **Replace MetaAgent logic:** Instead of using `MetaAgent.run()` to drive the workflow, call into the Agent Squad orchestrator. For example, if using the Supervisor pattern, you will construct a `SupervisorAgent` (or similar) that internally routes between agents. When a user provides a goal or command, pass it to this new orchestrator rather than to MetaAgent. This ensures the orchestration logic (classification, planning, evaluation, execution sequence) is handled by Agent Squad’s robust framework.
  * **Leverage Agent Squad features:** Take advantage of Agent Squad’s capabilities such as intelligent intent routing and context management. If appropriate, use the Agent Squad **Classifier** to decide which agent (or workflow) should handle a given user query. However, for T‑Developer’s specific workflow, a classifier might not always be needed (since we know we want the development workflow agents), so the implementation might directly invoke the SupervisorAgent or DevCoordinator agent for every `tdev run`/`orchestrate` command. In summary, the **custom orchestration code is replaced by Agent Squad’s orchestration logic**, aligning T‑Developer with the latest best practices in multi-agent coordination.

* [ ] **Refactor CLI Commands to Remove Legacy Assumptions:** Audit all CLI subcommands that depended on the old orchestrator and update them to use the new Agent Squad-based workflow. Legacy support can be dropped unless absolutely necessary for basic usage.

  * **`tdev orchestrate`:** Update this command to invoke the Agent Squad orchestrator instead of looking up `OrchestratorTeam`. For example, if you create a new orchestrator instance (like a SupervisorAgent) on the fly, call its execution method here. The CLI code that fetched OrchestratorTeam from the registry should be removed. Instead, construct or retrieve the Agent Squad orchestrator (possibly via a new function `get_orchestrator()` or similar) and pass the user’s goal and optional code to it.
  * **`tdev run` (workflow execution):** Determine if the static workflow mechanism is still needed. Previously, `tdev run <workflow_id>` loaded a JSON workflow and stepped through it (a stubbed implementation). Given that Agent Squad’s Planner can dynamically create workflows, you may **deprecate the manual `compose`/`run` flow** in favor of always using the PlannerAgent’s plan. If you keep `tdev run`, refactor it to utilize the new orchestrator: e.g. interpret the workflow JSON and perhaps execute it via the WorkflowExecutorAgent under Agent Squad’s coordination. If manual workflows are not crucial, consider removing this command to avoid confusion.
  * **`tdev compose`:** This command defined workflows by listing agent names. With the new approach, explicit composition might be less important (the PlannerAgent now generates workflows). You can remove `compose` or repurpose it to call Agent Squad’s planning process. For instance, `tdev compose` could internally use the PlannerAgent to output a workflow plan for a given goal. If you keep it, ensure it integrates with the new agents (e.g. using PlannerAgent’s logic instead of manually assembling steps).
  * **`tdev generate`:** Ensure the agent and tool generation commands continue to function after the refactor. The generation commands (`tdev generate agent/tool`) use the AutoAgentComposerAgent (codenamed “Agno”) to create new components. This path should remain mostly unchanged; however, verify that AutoAgentComposerAgent is properly registered and working under the new regime (it might internally rely on PlannerAgent or others). If AutoAgentComposerAgent used MetaAgent or OrchestratorTeam for any reason, update it to use Agent Squad where needed. In general, **no legacy orchestrator references should remain** in any CLI command after this step.
  * **Other CLI adjustments:** If there are commands like `tdev run-team` (to run a team by name), decide if they should be retained. With Agent Squad, the concept of a “Team” is replaced or superseded by the Supervisor/coordinator agent. You may remove `run-team` entirely or limit its use to any remaining simple teams (e.g. the example `DoubleEchoTeam`). Document any CLI changes clearly in the CLI usage guide so users know how to run workflows under the new system.

* [ ] **Implement a DevCoordinator/Supervisor Agent for T‑Developer Workflow:** Introduce a specialized orchestrator agent within the Agent Squad framework that replicates T‑Developer’s workflow pattern (Classifier → Planner → Evaluator → Executor sequence). This can be achieved by leveraging Agent Squad’s **SupervisorAgent** or by creating a custom coordinator agent that is compatible with Agent Squad’s architecture.

  * **Use Agent Squad’s SupervisorAgent:** The easiest way to orchestrate multiple agents is to use the built-in `SupervisorAgent` as the top-level coordinator. In this mode, you create a `SupervisorAgent` instance configured with:

    * **Lead agent:** an LLM-based agent (e.g. a BedrockLLMAgent or AnthropicAgent) that will serve as the “brain” of the coordinator. This lead agent’s role is to decide which team member to call at each step. Provide it with a system prompt that encodes the T‑Developer workflow logic (for example: *“You are a development coordinator. First, if code is provided, ask the Classifier agent to analyze it. Then always instruct the Planner agent to propose a plan. Next, use the Evaluator agent to review the plan; refine the plan if needed. Finally, call the Executor agent to perform the plan and return the result.”*). This prompt guides the lead LLM to follow the required sequence.
    * **Team members:** the core T‑Developer agents (likely wrapped as Agent Squad agents or tools – see Task 6). Add the `ClassifierAgent`, `PlannerAgent`, `EvaluatorAgent`, and `WorkflowExecutorAgent` as the team that the Supervisor can call upon. In SupervisorAgent’s options, you can list these under the `team` parameter, each with a name and description. For example, create something like:

      ```python
      from agent_squad.agents import SupervisorAgent, SupervisorAgentOptions, BedrockAgent
      # ... (import or wrap T-Dev agents as needed)
      options = SupervisorAgentOptions(
          name="DevCoordinator",
          description="Coordinates T-Developer workflow (Classifier->Planner->Evaluator->Executor)",
          lead_agent=BedrockAgent(...),  # e.g., an LLM agent from Bedrock as the supervisor's brain
          team=[ wrapped_classifier, wrapped_planner, wrapped_evaluator, wrapped_executor ]
      )
      dev_coordinator = SupervisorAgent(options)
      ```

      Each team agent should be configured such that the lead agent can invoke it (through Agent Squad’s tool interface or messaging). The SupervisorAgent uses an “agents-as-tools” approach, meaning it will expose each team member as a tool the lead agent can call. Ensure the `name` you give each agent in the team matches how the lead agent will reference them in the prompt (e.g. "Classifier", "Planner", etc.).
    * **Workflow enforcement:** Because SupervisorAgent by default allows flexible, possibly parallel interactions, you should enforce a sequential flow in the lead agent’s instructions (the system prompt guidelines). Emphasize ordering (Classifier first, etc.) and that it should call agents one at a time in the correct order (unless parallelism is desired for certain steps). You may also disable or ignore the guideline about parallelizing if it conflicts with the desired sequence. The result is a **DevCoordinator** orchestrator that *follows T‑Developer’s four-phase workflow within the Agent Squad paradigm*.
  * **Alternative – Custom Coordinator Agent:** If using a heavy LLM as the coordinator is not desirable for every run (due to cost or complexity), you can implement a custom `DevCoordinatorAgent` in code that fits Agent Squad’s interface. For example, subclass Agent Squad’s base `Agent` class (or implement a handler) that overrides `process_request` to call the T‑Dev agents in sequence (essentially a coded orchestrator, similar to the old MetaAgent but now as part of Agent Squad). This agent would not do any AI reasoning; it would simply orchestrate deterministically: first call the ClassifierAgent (if needed), then PlannerAgent, etc., and aggregate the results. Make sure this custom orchestrator agent can be invoked by the Agent Squad system (e.g. the classifier might choose it, or it could even act as the lead of a Supervisor if meta-orchestration is layered). While this approach gives you more control over the sequence, it bypasses the dynamic “agents as tools” logic – so choose it only if a non-LLM coordinator is preferred.
  * **Code integration:** Whichever approach you choose, add this new coordinator agent to T‑Developer’s codebase (e.g., as a new class in `tdev/agents/dev_coordinator_agent.py`). Document its role and how it maps to the previous MetaAgent/OrchestratorTeam behavior. The goal is to have a clear one-to-one replacement: all high-level workflow orchestration is handled by **Agent Squad’s orchestrator** (with the DevCoordinator or Supervisor logic), rather than by any T‑Dev-specific code. This new component becomes the heart of the system, ensuring the user’s goal flows through Classifier → Planner → Evaluator → Executor as before, but now under a more flexible and powerful orchestrator.

* [ ] **Dynamic Registration of Agents/Tools in Agent Squad:** Ensure that all T‑Developer agents and tools are seamlessly registered with the Agent Squad orchestrator at runtime. The existing `AgentRegistry` in T‑Developer should feed into Agent Squad’s mechanism so that new or existing agents are known to the orchestrator without manual coding.

  * **Registry integration point:** After the T‑Dev registry is initialized or updated (e.g., when `initialize_registry()` runs, or when a user registers a new component via `tdev register`), trigger a synchronization with Agent Squad. You might introduce a function like `sync_with_squad(registry)` that iterates over all registered agents and tools and adds them to the Agent Squad system.
  * **Registering agents with classifier (if applicable):** If you use Agent Squad’s **Classifier** for intent routing, you will want to provide it with the list of available agents and their metadata. For each agent in the T‑Dev registry, retrieve its name, description, and capabilities. Use this to configure Agent Squad’s classifier (for example, if Agent Squad provides a classifier that takes a list of agent names and descriptions to choose from). This will allow the classifier to pick the correct agent or coordinator for a given user query. In our context, you might only have one top-level coordinator agent for all “development” tasks, but if the user adds other independent agents (say an `EchoAgent` or a Q\&A agent), the classifier could decide when to use those. **Ensure that any agent present in T‑Dev’s registry is known to Agent Squad’s routing logic.**
  * **Registering tools as Agent Squad tools:** T‑Dev “tools” (0-brain functions annotated with `@tool`) should also be integrated. In Agent Squad, tools are often used by agents (especially LLM-based agents) to perform specific actions (e.g., an API call). For each tool in the registry, create an Agent Squad `AgentTool` or include it in an `AgentTools` collection that can be attached to agents. For instance, if you have an `EchoTool` in T‑Dev, expose it as a tool that agents can invoke. In the SupervisorAgent scenario, you might add such tools as `extra_tools` in the Supervisor’s options, or attach them to specific agents (like the PlannerAgent could use a code-execution tool, etc.). The integration mechanism could map T‑Dev tool functions to Agent Squad’s tool interface by wrapping the Python function accordingly.
  * **Dynamic loading on the fly:** The registration process should be dynamic. For example, if a user runs `tdev register tdev/agents/MyNewAgent.py`, the code should not only update the JSON registry but also instantiate the new agent (via `get_instance`) and inform the Agent Squad orchestrator about this new agent. This could involve adding the agent to the classifier’s list or to a SupervisorAgent’s team if appropriate. The design might vary: you could keep a **single Agent Squad orchestrator instance** alive and update its agents list, or re-instantiate the orchestrator when needed to include new agents. In either case, **tie the lifecycle of T‑Dev’s registry to Agent Squad’s configuration** so that both remain in sync.
  * **No static agent lists:** Avoid hard-coding the agent lineup in the Agent Squad orchestrator. Instead, programmatically pull from `AgentRegistry`. For example, rather than manually specifying the team members in code, you might do:

    ```python
    core_agents = ["ClassifierAgent", "PlannerAgent", "EvaluatorAgent", "WorkflowExecutorAgent"]  # plus any others
    for agent_name in core_agents:
        agent_instance = registry.get_instance(agent_name)
        supervisor_team.append(wrap_for_squad(agent_instance))
    ```

    This way, if core agent classes are swapped or extended in the registry, the orchestrator picks it up. The same principle goes for any new agent: if a user adds `CustomAgent`, and if it’s meant to operate independently (not necessarily in the dev workflow team), ensure the Agent Squad classifier knows about `CustomAgent` so it can route queries to it when appropriate.
  * **Agent naming and addressing:** Use consistent naming between the registry and Agent Squad. The `name` field in T‑Dev’s registry entries (and the class names) should correspond to how Agent Squad identifies agents. For instance, if the registry has `"PlannerAgent"` with some class path, ensure that when you register it with Agent Squad, it’s labeled as “PlannerAgent” with the same description. This will help the classifier or the coordinating agent recognize it. In summary, **make the T‑Developer AgentRegistry the single source of truth** for available agents/tools, and have the Agent Squad orchestrator dynamically reflect that list.

* [ ] **Adapt Core Agents to Agent Squad’s Interface:** Refactor or wrap all the primary T‑Developer agents so that they comply with Agent Squad’s expected agent interface and can participate in the new orchestration smoothly. Agent Squad likely defines a common Agent base class or protocol (with methods like `process_request` or similar). All core agents (ClassifierAgent, PlannerAgent, EvaluatorAgent, WorkflowExecutorAgent, etc.) need to adhere to this interface.

  * **Uniform agent API:** Modify the `Agent` base class in T‑Dev (`tdev.core.agent.Agent`) or create adapter classes so that each agent has the methods and properties Agent Squad expects. For example, Agent Squad’s agents might use a method `process_request(input, user_id, session_id, ...)` instead of the simple `run(input_data)` that T‑Dev uses. You can bridge this gap by implementing a `process_request` in each agent that internally calls the existing `run` logic. If Agent Squad requires async methods (depending on the framework’s design), you might need to make `run` async or provide an awaitable wrapper. The goal is that the new orchestrator can invoke T‑Dev’s agents as if they were native Agent Squad agents.
  * **Wrap agents as needed:** You might not want to alter the core logic of Classifier/Planner/etc. Instead, consider **wrapper classes** or functions. For instance, create an Agent Squad compatible class for each that holds a reference to the T‑Dev agent and calls its `run` method when invoked. This wrapper can subclass `agent_squad.agents.Agent` (or a generic Agent class from the framework) so that it can be inserted into the Supervisor’s team or used by the classifier. For example:

    ```python
    from agent_squad.agents import Agent as SquadAgent, AgentOptions
    class SquadWrapperAgent(SquadAgent):
        def __init__(self, tdev_agent):
            opts = AgentOptions(name=tdev_agent.name, description=tdev_agent.description)
            super().__init__(opts)
            self._tdev_agent = tdev_agent
        async def process_request(self, input_text, user_id, session_id, chat_history, additional_params=None):
            # Convert input_text or chat_history into the format expected by the T-Dev agent.
            result = self._tdev_agent.run(input_text) 
            # Here, input_text might be a file path or JSON depending on agent; adapt accordingly.
            return {"text": str(result)}
    ```

    The above is a sketch – the actual implementation will depend on how Agent Squad expects responses (possibly as `ConversationMessage` objects or plain text). The key idea is to **encapsulate each T‑Dev agent behind an interface that Agent Squad’s orchestrator can call**.
  * **Ensure proper input/output handling:** T‑Dev agents currently pass structured data between each other (e.g., PlannerAgent might output a workflow dictionary, EvaluatorAgent might output a score with feedback list, etc.). Agent Squad, especially if using an LLM lead, will likely pass information as text. You need to make sure the information flows correctly: the coordinator (or lead agent) should supply each agent with the right input and parse the output for the next step. This might involve adding translation layers. For example, the Supervisor’s lead LLM could communicate something like *“Classifier: \[please classify code in file X]”* and the system would route that to ClassifierAgent.run(file\_path). When ClassifierAgent returns a JSON like `{"type": "tool", ...}`, you must convey that back to the lead agent (perhaps as a textual summary or just store it in memory for the next call). Designing a consistent **communication schema** between the LLM orchestrator and the code-based agents is important. You may decide to simplify this by handling some steps outside the LLM: e.g., perform code classification in Python, then only feed the classification result into the LLM for planning. Choose an approach that maintains the integrity of the workflow.
  * **Validate each core agent:** After refactoring, test each core agent in isolation to ensure it still performs its role. For instance, verify that ClassifierAgent can still classify a file correctly and that PlannerAgent given a goal + classification returns a sensible plan. Since their implementations aren’t changing drastically (mostly interface), they should remain correct, but any tweaks for integration (like making methods async or handling different input types) should not break their core logic. All core agents should now behave like first-class citizens of the Agent Squad framework – meaning the new orchestrator can call them and get results without special-casing.

* [ ] **Update CLI Commands to Use the New Orchestrator Path:** Modify the user-facing CLI commands (such as `tdev run`, `tdev orchestrate`, `tdev generate`, etc.) so that they trigger the refactored orchestration flow using Agent Squad. The CLI should hide the complexity of Agent Squad and provide a seamless experience similar to before.

  * **`tdev run` / `tdev orchestrate` with Agent Squad:** Decide on a unified entrypoint for users to execute a goal. You might keep the `tdev orchestrate` command as the primary way to run a goal through the system. Implement this command to instantiate or retrieve the Agent Squad orchestrator (the DevCoordinator/SupervisorAgent from Task 4) and call it. For example:

    ```python
    # Pseudo-code inside CLI command
    orchestrator = get_dev_coordinator()  # either create a new SupervisorAgent or use a singleton
    result = orchestrator.process(goal_text, code_path)
    ```

    If `code_path` is provided via `--code`, you may handle the classification either before calling `process` or let the orchestrator handle it. The CLI should then print out or return the result from the orchestrator. Essentially, the CLI no longer directly calls PlannerAgent or OrchestratorTeam – it delegates entirely to Agent Squad’s orchestrator mechanism.
  * **`tdev generate` using new orchestration (if applicable):** The generation subcommands might benefit from the new orchestrator indirectly. For example, the AutoAgentComposerAgent might itself use the Planner to generate code for a new agent. If so, when `composer.run()` is invoked in `tdev generate agent/tool`, ensure that behind the scenes the PlannerAgent or any agent it uses are running under the Agent Squad context (with any new interfaces). It might be prudent to write a thin wrapper or update AutoAgentComposerAgent so that it can call the PlannerAgent’s new interface or even involve the orchestrator if needed (e.g., maybe the composer could ask the EvaluatorAgent to critique the generated agent code). These enhancements are optional, but the key is that `tdev generate` should continue to function correctly. You might add logging to show that generation is utilizing the updated agents.
  * **Other CLI commands:** Verify that commands like `tdev test <AgentName>` still work. The `AgentTesterAgent` should be unaffected by orchestrator changes, but since the registry and agent interfaces changed, double-check that `AgentTesterAgent` can retrieve and run the target agent. If needed, update it to use the new interface (for example, if it was calling agent.run() directly, it still can – but if that agent is now a Squad-wrapped agent, ensure .run still exists or adapt the tester to call the appropriate method).
  * **Legacy command cleanup:** Remove any CLI command that no longer makes sense after the integration. For instance, if we removed `compose` and static workflows, update the CLI help text to reflect that. If `run-team` is deprecated, mention the new approach (like using `orchestrate` or possibly a new command to run a Supervisor team scenario). The final CLI should present a coherent set of commands that revolve around the Agent Squad orchestrator (for running goals and managing agents/tools) without exposing any of the old OrchestratorTeam/MetaAgent concepts.

* [ ] **Add Comprehensive Tests for the New Orchestration Path:** Develop unit tests and integration tests to cover the refactored orchestrator and registry integration. Aim for **at least 80% code coverage** on the new or changed modules, especially focusing on the critical path of orchestration and dynamic agent management.

  * **Unit tests for orchestrator logic:** Write unit tests for the DevCoordinator/SupervisorAgent behavior. If you implemented a custom `DevCoordinatorAgent`, create tests that simulate various input scenarios: e.g., a basic goal with no code, a goal with a code path (requiring classification), a scenario where the Evaluator suggests a refinement (you can simulate an EvaluatorAgent returning a low score to see if the Planner is called twice). Use dummy or stubbed agents if needed (for instance, a fake PlannerAgent that returns a preset plan) to isolate and verify the orchestrator’s decision-making. The tests should assert that each sub-agent is invoked in the proper order and that the final result aggregates correctly.
  * **Agent interface tests:** For each core agent that was adapted (Classifier, Planner, Evaluator, Executor), create targeted tests to ensure they work with the new interface. For example, if you added a `process_request` method or made them async, call those in a test and verify you get expected outputs. Also test the wrapper classes if you introduced them – e.g., given an input, does `SquadWrapperAgent` properly call the underlying agent’s `run()` and handle the response format? These tests help catch any misalignment in input/output format early.
  * **Registry and dynamic loading tests:** Test the integration of the registry with Agent Squad. One approach is to simulate registering a new agent or tool and then verifying it’s reflected in the orchestrator. For instance, call `registry.register("TestAgent", ...)` with a fake agent class, then ensure that either the Agent Squad classifier’s agent list or the Supervisor’s team list gets updated to include "TestAgent". If you have a function like `sync_with_squad`, invoke it in a test with a known set of registry entries and assert that the Agent Squad orchestrator was configured with corresponding agents.
  * **End-to-end integration test:** Write at least one integration test that runs a full cycle: initialize the system, call the CLI (or the underlying orchestration function) with a sample goal, and observe the outcome. This could be a lightweight scenario such as using the EchoAgent/EchoTool: e.g., `tdev orchestrate "Echo Hello World" --goal "Echo Hello World"` which should route to EchoAgent and simply return the input. Or a slightly more involved scenario using the core workflow: provide a dummy goal and dummy code file, and assert that the final result is in the expected format. This test will go through the Agent Squad orchestrator, exercising the classifier (if used) and the Supervisor/DevCoordinator with actual agents. Use the output of the WorkflowExecutorAgent (which might produce a result dict or message) and verify it’s returned through the orchestrator to the CLI.
  * **Coverage measurement:** Utilize a coverage tool (like `pytest --cov`) to ensure that the new code paths are hit. Focus on covering error paths too: e.g., what if a required agent is missing in the registry? (The MetaAgent used to handle missing Planner or Executor by returning an error; the new orchestrator should similarly be tested for graceful failure if something isn’t configured.) Also test edge cases like an empty goal string, or options parsing in the CLI to ensure nothing was broken in translation. Achieving 80% coverage will likely require testing most of the orchestrator functions and some CLI invocations. These tests not only prevent regressions but also document the expected behavior of the new system.
  * **Regression tests for legacy removal:** If possible, include tests that confirm legacy components are truly gone or inactive. For example, attempting to call `registry.get_instance("OrchestratorTeam")` after init should fail or return None. This isn’t a typical unit test (since it’s testing absence), but it can be useful to ensure no accidental fallback to old logic. The main focus, however, should be on positive testing of the new orchestrator pipeline.

* [ ] **Update Architecture & Design Documentation:** Revise the project’s markdown documentation to reflect the new architecture and how the Agent Squad orchestrator works in T‑Developer. Each relevant design doc should be updated with both conceptual overviews and low-level details of the changes:

  * **`Architecture.md`:** Redraw or rewrite the system architecture description to place Agent Squad at the top. Explain that the “Meta-Agent Orchestrator” pattern has been replaced by the Agent Squad framework. Highlight that now an **Agent Squad Orchestrator (SupervisorAgent)** coordinates the core agents, providing more flexibility and scalability. If previously the document outlined Tools/Agents/Teams and the MetaAgent, update that section to describe Tools/Agents and the new **Orchestrator (Squad Coordinator)**. You might include a high-level flow diagram where the user’s request goes into the Agent Squad orchestrator, which then engages Classifier/Planner/etc., similar to the original flow but with new terminology. Mention the AWS origin of Agent Squad and that it’s an open-source library integrated into T‑Developer for orchestration duties.
  * **`Orchestrator.md`:** This document (if it didn’t exist, create it) should detail how the orchestration logic works now. Remove any mention of OrchestratorTeam or MetaAgent. Instead, introduce the **SupervisorAgent (DevCoordinator)** concept. Describe its components: the lead agent (and what LLM or model it uses), the team of core agents, and how it uses an “agents as tools” approach to delegate tasks. Walk through the orchestration steps in narrative form: e.g., *“When a user input is received, the SupervisorAgent’s lead (LLM) determines the need to classify code and invokes the ClassifierAgent. The classification result is then used to prompt the PlannerAgent for a workflow. The plan may be revised after evaluation by EvaluatorAgent. Finally, the plan is executed by WorkflowExecutorAgent. The SupervisorAgent aggregates the responses and returns the final result to the user.”* Emphasize differences from the old design: no more hardcoded sequence in Python code – now the sequence is either learned by the LLM agent or handled by the new DevCoordinator logic, providing a more flexible framework.
  * **`Registry.md`:** Update the registry documentation to explain how agent and tool registration now ties into the Agent Squad orchestrator. Document the new *dynamic registration mechanism* introduced in Task 5. For example, after listing how to register a component (via CLI or code), add a section about *“Integration with Orchestrator”* describing that each registration updates the running orchestrator’s agent/tool list. If previously this doc enumerated the JSON schema (name, class, brain\_count, etc.), you can retain that but note that, for instance, *“type 'agent' components are automatically wrapped for inclusion in the Agent Squad system at runtime.”* Clarify that while the registry file still exists for persistence, the active orchestrator will load from it so that any new agent is ready to use immediately in conversations or workflows.
  * **`ExecutionFlow.md`:** Provide a detailed, step-by-step breakdown of the execution flow under the new system. This is essentially the runtime sequence from user input to result, updated for Agent Squad. Include the role of the classifier (if any) and the DevCoordinator/Supervisor:

    1. **User Input:** A user invokes the CLI (or API) with a goal (and optionally a code snippet or file path and options).
    2. **Agent Squad Orchestrator Activation:** The input is passed to the Agent Squad orchestrator (the SupervisorAgent/DevCoordinator). If a code file is included, the orchestrator first utilizes the ClassifierAgent to determine what the file represents (tool/agent/team). This classification can be done either automatically by the orchestrator’s logic or explicitly before orchestration begins – document whichever approach you implemented.
    3. **Planning:** The orchestrator (via the lead agent or coordinator logic) invokes the PlannerAgent with the user’s goal (and classification result, if any). The PlannerAgent returns a proposed **workflow plan** (describe what form this plan takes – e.g., a JSON with step list). This plan outlines how to fulfill the goal, typically listing which agents or tools to call in sequence.
    4. **Evaluation & Refinement:** The orchestrator next calls the EvaluatorAgent to assess the proposed plan. Document that the EvaluatorAgent produces a score/feedback. If the plan is suboptimal (score below threshold), the orchestrator will trigger a refinement cycle: the PlannerAgent is called again with feedback to adjust the plan. This loop (Planner -> Evaluator) may repeat until an acceptable plan is obtained or a max iteration is reached. Explain this iterative loop clearly, as it is a critical part of T‑Developer’s workflow quality control.
    5. **Execution:** Once the plan is finalized, the orchestrator invokes the WorkflowExecutorAgent to carry out the plan steps. The Execution flow might involve running multiple agents/tools as specified by the plan. Note that under Agent Squad, the SupervisorAgent could potentially execute steps in parallel if designed so – but in our use-case, it will likely execute sequentially as per the plan. The `ExecutionFlow.md` should describe that each step in the plan is executed in order, utilizing either direct agent calls or Agent Squad’s messaging (depending on implementation). If any step fails or produces new info, consider how the orchestrator reacts (for now, likely it just continues or stops on error).
    6. **Result Aggregation:** After execution, the final result (for example, a completed code artifact, or a summary of actions) is returned by the WorkflowExecutorAgent. The orchestrator collects this and presents it as the outcome. If using SupervisorAgent with an LLM lead, the lead agent might formulate the final answer to the user based on all the context. Otherwise, the DevCoordinator can simply output the WorkflowExecutor’s result. Mention how the result is structured (e.g., printed to console, saved to a file, etc., as per CLI).
    7. **Context Handling:** If Agent Squad’s context management is in use, describe how conversation state is maintained. For instance, if a user were to have a multi-turn session, Agent Squad could keep track of previous interactions. T‑Developer might not yet support interactive conversations, but if it does (or will), note that Agent Squad’s memory system can maintain a **User-Supervisor memory** and **Supervisor-Team memory** for continuity. Even if not used now, it’s worth mentioning for completeness that the architecture is ready for iterative dialogues.
       By documenting the above, `ExecutionFlow.md` will give developers and users a clear picture of how a request moves through the system in this new design. Include diagrams or sequence charts if helpful, showing the new components (ClassifierAgent, PlannerAgent, etc. under the Agent Squad Orchestrator umbrella) and the order of interactions.
  * **Other documentation:** Review any other markdown files (e.g., `AUTO_DEV_TEAM.md`, `CLI_USAGE.md`, etc.) for references to the old orchestrator or teams. Update terminology (replace “MetaAgent” with “Agent Squad orchestrator” or the name of your coordinator agent). Update any example commands and outputs to reflect the new CLI behavior. For instance, if previously `tdev orchestrate` output some JSON, and now it might output a message from the LLM, adjust the examples. Ensure the README’s quick start section is updated: the command `tdev orchestrate "Echo the input data"` should still work, but its internal mechanism is different now – you might want to note that Agent Squad is powering it behind the scenes.
  * **Emphasize benefits:** In the documentation, it’s useful to call out *why* this change was made. For example, *“We integrated AWS’s Agent Squad framework to manage our agents because it provides a more flexible and extensible orchestration mechanism, allowing parallel agent execution and intelligent routing, which prepares T‑Developer for more complex scenarios and future growth.”* This gives context to the reader that this is a forward-looking improvement.
  * Each doc should be written clearly and technically, as these are developer-facing design documents. Where appropriate, include references or footnotes to Agent Squad’s docs (for example, linking to Agent Squad’s SupervisorAgent introduction for readers who want to dive deeper). After these updates, the documentation should accurately describe the **new architecture and workflow**, enabling contributors to understand the system without knowledge of the removed legacy code.
